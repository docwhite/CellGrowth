#ifndef SCENE_H
#define SCENE_H

// Qt
#include <QObject>
#include <QOpenGLBuffer>
#include <QOpenGLFramebufferObject>
#include <QOpenGLShaderProgram>
#include <QOpenGLVertexArrayObject>
#include <QMatrix4x4>

// Project
#include "AbstractScene.h"
#include "ParticleSystem.h"
#include "Window.h"
#include "input.h"

////////////////////////////////////////////////////////////////////////////////
/// @file Scene.h
/// @author Ramon Blanquer
/// @version 0.0.1
/// @class Scene
/// @brief This is an example on how to subclass the AbstractScene and use your
/// OpenGL commands
///
/// In order to create your scene you need to subclass the AbstractScene through
/// public inheritance and write initialize() and paint(). Both are virtual, but
/// the paint() is pure virtual, initialize() is not.
///
/// There is just one requirement, AbstractScene::initialize() method must be
/// called from the Scene::initialize() in order to initialize the OpenGL
/// functions, that saves you from having to do it. Just make sure you call
/// the superclass method and you are good to go.
////////////////////////////////////////////////////////////////////////////////
class Scene : public QObject, public AbstractScene
{

public:
  //////////////////////////////////////////////////////////////////////////////
  /// @brief Constructor
  /// @param[in] _window The OpenGL window to associate the scene with
  //////////////////////////////////////////////////////////////////////////////
  Scene(Window *_window);

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Destructor, do all the OpenGL cleanup here
  //////////////////////////////////////////////////////////////////////////////
  ~Scene();

  //////////////////////////////////////////////////////////////////////////////
  /// @brief All the OpenGL initialization should be done in this method
  //////////////////////////////////////////////////////////////////////////////
  void initialize();

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Gets called everytime we want to draw the scene
  //////////////////////////////////////////////////////////////////////////////
  void paint();

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Initializes a screen quad for deferred shading.
  //////////////////////////////////////////////////////////////////////////////
  void prepareQuad();

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Initializes particle system geometry.
  //////////////////////////////////////////////////////////////////////////////
  void prepareParticles();

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Draws a quad object.
  //////////////////////////////////////////////////////////////////////////////
  void drawQuad();

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Draws particles.
  //////////////////////////////////////////////////////////////////////////////
  void drawParticles();

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Sets up a frame buffer object and initializes it.
  //////////////////////////////////////////////////////////////////////////////
  void setupFBO();

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Every time a key press event is intercepted on the window it will
  /// run this function.
  //////////////////////////////////////////////////////////////////////////////
  virtual void keyPressed(QKeyEvent* ev);

  virtual void keyReleaseEvent(QKeyEvent *key);

  virtual void mouseMoveEvent(QMouseEvent *event);

  virtual void mousePressEvent(QMouseEvent *event);

  virtual void mouseReleaseEvent(QMouseEvent *event);

  virtual void wheelEvent(QWheelEvent *event);

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Update matrices according to the new Window size.
  //////////////////////////////////////////////////////////////////////////////
  virtual void windowResized(int _w, int _h);

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Now it selects randomly a particle, it splits it and advances them.
  //////////////////////////////////////////////////////////////////////////////
  void updateParticleSystem();

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Sends updated particle information to OpenGL.
  //////////////////////////////////////////////////////////////////////////////
  void sendParticleDataToOpenGL();

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Updates particle system model matrix.
  //////////////////////////////////////////////////////////////////////////////
  QMatrix4x4 updateModelMatrix();

private:
  //////////////////////////////////////////////////////////////////////////////
  /// @brief Particle system associated with the scene.
  //////////////////////////////////////////////////////////////////////////////
  ParticleSystem m_ps;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief All the particle positions and radius ready for OpenGL to be drawn.
  //////////////////////////////////////////////////////////////////////////////
  std::vector<float> m_packagedParticleData;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Frame buffer object we write to for the deferred shading.
  //////////////////////////////////////////////////////////////////////////////
  QOpenGLFramebufferObject *m_FBO;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief View matrix for the particle system
  //////////////////////////////////////////////////////////////////////////////
  QMatrix4x4 m_viewMatrix;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Model matrix for the particle system
  //////////////////////////////////////////////////////////////////////////////
  QMatrix4x4 m_modelMatrix;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Projection matrix for the particle system
  //////////////////////////////////////////////////////////////////////////////
  QMatrix4x4 m_projectionMatrix;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Quad shader program.
  //////////////////////////////////////////////////////////////////////////////
  QOpenGLShaderProgram *m_quad_program;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Particles shader program.
  //////////////////////////////////////////////////////////////////////////////
  QOpenGLShaderProgram *m_part_program;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief VAO that will store the state for drawing the Quad.
  //////////////////////////////////////////////////////////////////////////////
  QOpenGLVertexArrayObject *m_quad_vao;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief VAO that will store the state for drawing the Particles.
  //////////////////////////////////////////////////////////////////////////////
  QOpenGLVertexArrayObject *m_part_vao;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief VBO buffer that stores the point data for the quad.
  //////////////////////////////////////////////////////////////////////////////
  QOpenGLBuffer m_quad_vbo;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief VBO buffer that stores the point data for the particles
  //////////////////////////////////////////////////////////////////////////////
  QOpenGLBuffer m_part_vbo;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Index for the RenderPass subroutine to be called.
  //////////////////////////////////////////////////////////////////////////////
  GLuint m_activeRenderPassIndex;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Index for RenderPass subroutine that draws normals.
  //////////////////////////////////////////////////////////////////////////////
  GLuint m_normalShadingIndex;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Index for RenderPass subroutine that draws world-space positions.
  //////////////////////////////////////////////////////////////////////////////
  GLuint m_positionShadingIndex;

  /////////////////////////////////////////////////////////////////////////////
  /// @brief Manager processing inputs and handling the camera
  //////////////////////////////////////////////////////////////////////////////
  InputManager inputManager;

  /////////////////////////////////////////////////////////////////////////////
  /// @brief List of all scene objects
  //////////////////////////////////////////////////////////////////////////////
  std::vector<std::shared_ptr<SelectObject>> objectList;


};

#endif // SCENE_H
