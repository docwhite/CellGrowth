////////////////////////////////////////////////////////////////////////////////
/// @file Scene.h
/// @author Ramon Blanquer
/// @version 0.0.1
////////////////////////////////////////////////////////////////////////////////

#ifndef SCENE_H
#define SCENE_H

// Qt
#include <QObject>
#include <QOpenGLBuffer>
#include <QOpenGLFramebufferObject>
#include <QOpenGLShaderProgram>
#include <QOpenGLVertexArrayObject>
#include <QMatrix4x4>

// Project
#include "AbstractScene.h"
#include "ParticleSystem.h"
#include "Window.h"
#include "InputManager.h"

////////////////////////////////////////////////////////////////////////////////
/// @class Scene
/// @brief This is an example on how to subclass the AbstractScene and use your
/// OpenGL commands
///
/// In order to create your scene you need to subclass the AbstractScene through
/// public inheritance and write initialize() and paint(). Both are virtual, but
/// the paint() is pure virtual, initialize() is not.
///
/// There is just one requirement, AbstractScene::initialize() method must be
/// called from the Scene::initialize() in order to initialize the OpenGL
/// functions, that saves you from having to do it. Just make sure you call
/// the superclass method and you are good to go.
////////////////////////////////////////////////////////////////////////////////
class Scene : public QObject, public AbstractScene
{

public:
  //////////////////////////////////////////////////////////////////////////////
  /// @brief Constructor
  /// @param[in] _window The OpenGL window to associate the scene with.
  //////////////////////////////////////////////////////////////////////////////
  Scene(Window *_window);

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Destructor, do all the OpenGL cleanup here.
  //////////////////////////////////////////////////////////////////////////////
  ~Scene();

  //////////////////////////////////////////////////////////////////////////////
  /// @brief All the OpenGL initialization should be done in this method.
  //////////////////////////////////////////////////////////////////////////////
  void initialize();

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Gets called everytime we want to draw the scene.
  //////////////////////////////////////////////////////////////////////////////
  void paint();

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Initializes a screen quad for deferred shading.
  //////////////////////////////////////////////////////////////////////////////
  void prepareQuad();

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Initializes particle system geometry.
  //////////////////////////////////////////////////////////////////////////////
  void prepareParticles();

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Draws a quad object.
  //////////////////////////////////////////////////////////////////////////////
  void drawQuad();

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Draws particles.
  //////////////////////////////////////////////////////////////////////////////
  void drawParticles();

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Draws the links on top of everything
  //////////////////////////////////////////////////////////////////////////////
  void drawLinks();

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Sets up a frame buffer object and initializes it.
  //////////////////////////////////////////////////////////////////////////////
  void setupFBO();

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Creates and initialises lights and adds them to the list of
  /// objects.
  //////////////////////////////////////////////////////////////////////////////
  void setupLights();

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Generates OpenGL vertex data for a sphere of _num_subdivisions
  /// subdivisions. It will get stored in m_sphere_data.
  /// @param[in] _num_subdivisions Recursion level for icosahedra subdivision.
  //////////////////////////////////////////////////////////////////////////////
  void generateSphereData(uint _num_subdivisions);

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Now it selects randomly a particle, it splits it and advances them.
  //////////////////////////////////////////////////////////////////////////////
  void updateParticleSystem();

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Sends updated particle information to OpenGL.
  //////////////////////////////////////////////////////////////////////////////
  void sendParticleDataToOpenGL();

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Updates particle system model matrix.
  //////////////////////////////////////////////////////////////////////////////
  void updateModelMatrix();

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Every time a key press event is intercepted on the window it will
  /// run this function.
  //////////////////////////////////////////////////////////////////////////////
  virtual void keyPressed(QKeyEvent* ev);

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Key release event function.
  //////////////////////////////////////////////////////////////////////////////
  virtual void keyReleaseEvent(QKeyEvent *key);

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Mouse move event function.
  //////////////////////////////////////////////////////////////////////////////
  virtual void mouseMoveEvent(QMouseEvent *event);

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Mouse press event function.
  //////////////////////////////////////////////////////////////////////////////
  virtual void mousePressEvent(QMouseEvent *event);

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Mouse release event function.
  //////////////////////////////////////////////////////////////////////////////
  virtual void mouseReleaseEvent(QMouseEvent *event);

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Wheel event function. Will run when the wheel is spun in either
  /// direction.
  //////////////////////////////////////////////////////////////////////////////
  virtual void wheelEvent(QWheelEvent *event);

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Update matrices according to the new Window size.
  //////////////////////////////////////////////////////////////////////////////
  virtual void windowResized(int _w, int _h);

private:
  //////////////////////////////////////////////////////////////////////////////
  /// @brief Particle system associated with the scene.
  //////////////////////////////////////////////////////////////////////////////
  ParticleSystem m_ps;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Manager processing inputs and handling the camera.
  //////////////////////////////////////////////////////////////////////////////
  InputManager m_input_manager;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief List of all scene objects. Not including particles.
  //////////////////////////////////////////////////////////////////////////////
  std::vector<std::shared_ptr<SelectObject>> m_object_list;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Model matrix for the particle system.
  //////////////////////////////////////////////////////////////////////////////
  QMatrix4x4 m_model_matrix;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief View matrix for the particle system.
  //////////////////////////////////////////////////////////////////////////////
  QMatrix4x4 m_view_matrix;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Projection matrix for the particle system.
  //////////////////////////////////////////////////////////////////////////////
  QMatrix4x4 m_projection_matrix;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Framebuffer object we write to for the deferred shading.
  //////////////////////////////////////////////////////////////////////////////
  QOpenGLFramebufferObject *m_fbo;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Quad shader program.
  //////////////////////////////////////////////////////////////////////////////
  QOpenGLShaderProgram *m_quad_program;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Particles shader program.
  //////////////////////////////////////////////////////////////////////////////
  QOpenGLShaderProgram *m_part_program;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Particle links shader program.
  //////////////////////////////////////////////////////////////////////////////
  QOpenGLShaderProgram *m_links_program;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Manipulator shader program.
  //////////////////////////////////////////////////////////////////////////////
  QOpenGLShaderProgram *m_manipulator_program;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Light representation shader program.
  //////////////////////////////////////////////////////////////////////////////
  QOpenGLShaderProgram *m_sun_program;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief VAO that will store the state for drawing the quad.
  //////////////////////////////////////////////////////////////////////////////
  QOpenGLVertexArrayObject *m_quad_vao;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief VAO that will store the state for drawing the particles.
  //////////////////////////////////////////////////////////////////////////////
  QOpenGLVertexArrayObject *m_part_vao;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief VAO that will store state for drawing particle links.
  //////////////////////////////////////////////////////////////////////////////
  QOpenGLVertexArrayObject *m_links_vao;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief VBO buffer that stores the point data for the quad.
  //////////////////////////////////////////////////////////////////////////////
  QOpenGLBuffer m_quad_vbo;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief VBO buffer that stores the point data for the particles.
  //////////////////////////////////////////////////////////////////////////////
  QOpenGLBuffer m_part_vbo;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief EBO that stores the indices of the particles to draw links for.
  //////////////////////////////////////////////////////////////////////////////
  QOpenGLBuffer m_links_ebo;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Buffer object holding the the vertex data of the sphere on GPU.
  //////////////////////////////////////////////////////////////////////////////
  QOpenGLBuffer m_sphere_vbo;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Index for the RenderPass subroutine to be called.
  //////////////////////////////////////////////////////////////////////////////
  GLuint m_activeRenderPassIndex;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Index for RenderPass subroutine that draws normals.
  //////////////////////////////////////////////////////////////////////////////
  GLuint m_normalShadingIndex;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Index for RenderPass subroutine that draws world-space positions.
  //////////////////////////////////////////////////////////////////////////////
  GLuint m_positionShadingIndex;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief All the particle positions and radius ready for OpenGL to be drawn
  /// as instance position of the geometry defined in m_sphere_data.
  //////////////////////////////////////////////////////////////////////////////
  std::vector<GLfloat> m_particle_data;

  std::vector<uint> m_links_data;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Vertex data of the shape that will define an individual particle.
  //////////////////////////////////////////////////////////////////////////////
  std::vector<GLfloat> m_sphere_data;

};

#endif // SCENE_H
