#ifndef MANIPULATOR_H
#define MANIPULATOR_H

// QT
#include <QtGui/QOpenGLFunctions>
#include <QVector3D>

// OpenGL
#include <QOpenGLBuffer>
#include <QOpenGLShaderProgram>
#include <QOpenGLVertexArrayObject>

//////////////////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Struct storing the individual data for each manipulator arrow.
//////////////////////////////////////////////////////////////////////////////////////////////////////////
struct Arrow {
public:
    bool clicked;
    int axis;
    unsigned int numberOfPoints;
    QVector3D uniqueColour;
    QVector3D renderColour;
    QOpenGLBuffer *vbo;
    QOpenGLVertexArrayObject *vao;

};

class Manipulator
{


public:
  //////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Constructor taking position and the shaderprogram to be used for the manipulator.
  /// \param _position Position of the manipulator
  //////////////////////////////////////////////////////////////////////////////////////////////////////////
  explicit Manipulator (QVector3D _position, QOpenGLShaderProgram *_lightProgram);

  //////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Compares the given colour with the unique colour of each arrow in manipulator
  /// \param _colour Colour to be compared
  //////////////////////////////////////////////////////////////////////////////////////////////////////////
  int compareUniqueColour(QVector3D _colour);

  //////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Creates the manipulator geometry
  /// \param context QOpenGL scene context
  /// \param uColourVec Vector of unique colours to be assigned to the manipulator arrows
  //////////////////////////////////////////////////////////////////////////////////////////////////////////
  void createGeometry(QOpenGLContext *context, std::vector<QVector3D> uColourVec);

  //////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Draws the manipulator to the main buffer
  //////////////////////////////////////////////////////////////////////////////////////////////////////////
  void draw();

  //////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Draws the manipulator to a temporary buffer, using manipulators unique colours
  //////////////////////////////////////////////////////////////////////////////////////////////////////////
  void drawBackBuffer();

  //////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Processes mouse movement and calculates a new light position.
  /// \param offsetx The x offset
  /// \param offsetx The y offset
  /// \param offsetx The z offset
  /// \param currentPos Current light position
  /// \return QVector3D New position of light.
  //////////////////////////////////////////////////////////////////////////////////////////////////////////
  QVector3D processMouseMovement(float offsetx, float offsety, float offsetz, QVector3D currentPos);

  //////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Sets the manipulator arrows to clicked/not clicked
  /// \param uColourIdentity Unique colour that has been clicked
  /// \param state Boolean stating wether it is being run from mouse click or release. If the latter
  ///         clicked should always be set to false
  //////////////////////////////////////////////////////////////////////////////////////////////////////////
  void setClicked(QVector3D uColourIdentity, bool state);

  //////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Changes the colour of the manipulator arrows if the mouse is hovering over them
  /// \param axis Specifies which axis is being affected
  //////////////////////////////////////////////////////////////////////////////////////////////////////////
  void setHover(int axis);

  //////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Returns all arrows in the arrow vector
  /// \param axis Specifies which axis is being affected
  //////////////////////////////////////////////////////////////////////////////////////////////////////////
  void getArrows(std::vector<Arrow> &_arrows);


private:
  //////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Creates and sets up the vbo for the provided arrow object
  /// \param vertices Vertices being set to the VBO
  /// \param normals Normals being set to the VBO
  /// \param arrow Returns the arrow struct after the vbo has been added to it
  //////////////////////////////////////////////////////////////////////////////////////////////////////////
  void setupVBO(std::vector<QVector3D> vertices, std::vector<QVector3D> normals, Arrow &arrow);

  //////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Creates and sets up the vao for the provided arrow object
  /// \param arrow Returns the arrow struct after the vbo has been added to it
  /// \param vao The initialised vao to be set up
  //////////////////////////////////////////////////////////////////////////////////////////////////////////
  void setupVAO(Arrow &arrow, QOpenGLVertexArrayObject *vao);

  //////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief createArrow
  /// \param vao VAO being used to create arrow
  /// \param offsetPos Position of the created arrow
  /// \param uniqueColour the unique colour assigned to the arrow
  /// \param axis Axis assigned to the arrow
  /// Changes the colour of the manipulator arrows if the mouse is hovering over them
  //////////////////////////////////////////////////////////////////////////////////////////////////////////
  void createArrow(QOpenGLVertexArrayObject *vao, QVector3D offsetPos, QVector3D uniqueColour, int axis);

  //////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Manipulator shader program
  //////////////////////////////////////////////////////////////////////////////////////////////////////////
  QOpenGLShaderProgram *manipshaderp;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Manipulator position
  //////////////////////////////////////////////////////////////////////////////////////////////////////////
  QVector3D position;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Vector storing the arrows
  //////////////////////////////////////////////////////////////////////////////////////////////////////////
  std::vector<Arrow> arrows;


};


#endif
